%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% %
%%% % weiiszablon.tex
%%% % The Faculty of Electrical and Computer Engineering
%%% % Rzeszow University Of Technology diploma thesis Template
%%% % Szablon pracy dyplomowej Wydziału Elektrotechniki 
%%% % i Informatyki PRz
%%% % June, 2015
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt,twoside]{article}
\usepackage{weiiszablon}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{float}
\usepackage{easylist}

\definecolor{keywords}{RGB}{255,0,90}
\definecolor{comments}{RGB}{0,0,113}
\definecolor{red}{RGB}{160,0,0}
\definecolor{green}{RGB}{0,150,0}


\author{Kamil Madej}

% np. EF-123456, EN-654321, ...
\studentID{161876}

\title{Analiza i interpretacja wybranych metod całkowania numerycznego}
\titleEN{Temat pracy po angielsku}


%%% wybierz rodzaj pracy wpisując jeden z poniższych numerów: ...
% 1 = inżynierska	% BSc
% 2 = magisterska	% MSc
% 3 = doktorska		% PhD
%%% na miejsce zera w linijce poniżej
\newcommand{\rodzajPracyNo}{1}


%%% promotor
\supervisor{(dr. inż) Mariusz Borkowski (prof. PRz)}
%% przykład: dr hab. inż. Józef Nowak, prof. PRz

%%% promotor ze stopniami naukowymi po angielsku
\supervisorEN{(academic degree) Imię i nazwisko opiekuna}

\abstract{Treść streszczenia po polsku}
\abstractEN{Treść streszczenia po angielsku}

\begin{document}
\lstset{language=Python, 
        basicstyle=\ttfamily\small, 
        keywordstyle=\color{keywords},
        commentstyle=\color{comments},
        stringstyle=\color{red},
        showstringspaces=false,
        identifierstyle=\color{green},
        keywords=[2]{pow},
        keywordstyle=[2]{\color{orange}},
}
% strona tytułowa
\maketitle

\blankpage

% spis treści
\tableofcontents

\clearpage
\blankpage


\section{Wstęp/wprowadzenie}

Całkowanie numeryczne, zwane też kwadraturą to szeroka rodzina algorytmów służących do obliczania liczbowej wartości całki oznaczonej.
Przy pomocy kwadratur problemy matematyczne są formułowane w taki sposób, że można je rozwiązać przy pomocy operacji arytmetycznych.

Podstawowym problemem całkowania numerycznego jest obliczenie przybliżonego rozwiązanai całki oznaczonej

\begin{equation}
\int_a^b f(x) dx
\end{equation}

z pewnym stopniem dokładności\\
Do uzyskania tego celu opracowanych zostało wiele algorytmów. Najpopularniejsze z nich zostały bliżej omówionę w rozdziale 2.

\paragraph{Cel całkowania numerycznego}\mbox{} \\

Istnieje wiele przypadków gdy całkowania numeryczne jest lepszym rozwiązaniem niż całkowanie analityczne lub jedynym rozwiązaniem:
\begin{itemize}
	\item gdy całka z funkcji $f(x)$ znana jest jedynie dla pojedyńczych punktów, na przykład w przypadku próbkowania
	\item gdy wzór całki jest znany, ale znalezienie funkcji pierwotnej jest bardzo skomplikowane lub nie możliwe do zrobienia. Przykładem takiej funkcji jest $f(x) = exp(-x^2)$
	\item gdy znalezienie funkcji pierwotnej jest możliwe analitycznie, ale obliczenie numeryczne jest prostsze. Taki przypadek może wysąpić, gdy funkcja pierwotna jest dana jako nieskończony szereg lib iloczyn.
\end{itemize}
\cite{Intro1}

\clearpage

\section{Metody całkowania numerycznego}

Istnieje wiele sposobów na obliczanie pola powierzchni pod krzywą przy pomocy metod numerycznych. Do dwóch najbardziej popularnych i poruszanych w tej pracy należą:

\begin{enumerate}
	\item Kwadratury bazujące na interpolowaniu funkcji
	\begin{itemize}
		\item Metody Netwona-Cotesa
		\item Kwadratury Gaussa
		\item Metody adaptacyjne
	\end{itemize}
	\item Kwadratury bazujące na próbkowaniu funkcji
	\begin{itemize}
		\item Metody Monte Carlo
	\end{itemize}
\end{enumerate}

\subsection{Metody Netwona-Cotesa}

W analizie matematycznej, metodami Newtona-Cotesa, nazywamy grupę metod do całkowania numerycznego, które bazują na oszacowaniu wartości całki na skończonym przedziale, przy użyciu interpolacji wielomianem odpowiedniego stopnia, wyznaczając $n+1$ równo rozmieszczonych punktów, które dzielą przedział całkowania na $n$ podprzedziałów.
\cite{wikipedia}

Metodę Newtona-Cotesa dla $n+1$ punktów  można zdefiniować jako:

\begin{equation}
\int_a^b f(x)dx \approx \sum_{i=0}^n w_i f(x_i)
\label{Eq:rownanie}
\end{equation}


gdzie 
$x_i$ jest zbiorem równo rozmieszczonych punktów z przedziału [a,b]\\
a $w_i$ jest zbiorem wag


W metodzie Newtona-Cotesa wagi poszczególnych węzłów otrzymywane są poprzez interpolację wielomianem Lagrange'a:

\begin{equation}
\int_a^b f(x) dx \approx \int_a^b p(x) dx = \int_a^b \sum_{i=0}^{n} f_i L_{n,j}(x) dx = \sum_{i=0}^{n}(\int_a^b L_{n,j}(x)dx)f_i = \sum_{i=0}^{n} w_i f_i
\label{Eq:rownanie}
\end{equation}

\cite{web}

\clearpage	

\subsubsection{Metoda prostokątów}

Metoda prostokątów to najprostszy wariant metody Newtona-Cotesa gdzie całkę $\int_a^b f(x)$ przybliżamy przy użyciu interpolacji wielomianem Lagrange'a stopnia 1.
Dla pojedyńczego podprzedziału metoda prostokątów wygląda następująco:
\begin{equation}
\int_a^b f(x) = I = f(a)*h
\label{Eq:rownanie}
\end{equation}

dla n podprzedziałów metoda prostokątów przybiera formę:

\begin{equation}
\int_a^b f(x) = h * \sum_{i=0}^{n-1}f(x_i)
\label{Eq:rownanie}
\end{equation}

gdzie h jest szerokością pojedyńczego podprzedziału i równa się $h = \frac{b-a}{n}$  \cite{rect}

Listing 1 pokazuje przykładowy kod w języku Python implementujący metodą trapezów.
\begin{lstlisting}[caption={Kod w języku python implementujący metodę prostokątów}]
import numpy as np

def f_rectI(f,a,b,n):
    h = (b - a) / n

    X = np.linspace(a + 0.5 * h, b - 0.5 * h, num=n)

    Y = []
    for i in range(0, n):
        Y.append(f(X[i]))

    Y = np.array(Y)

    I = h * Y
    I = np.sum(I)
    return I
\end{lstlisting}
\label{Listing 1}



\subsubsection{Metoda trapezów}
Metoda trapezów to kolejny wariant metody Newtona-Cotesa, w którym całkę $\int_a^b f(x)$ przybliżamy przy użyciu wielomianu Lagrange'a stopnia 2.
Dla pojedyńczego podprzedziału metoda trapezów wygląda następująco:
\begin{equation}
\int_a^b f(x) =  \frac{1}{2}*h[f(a) + f(b)]
\label{Eq:rownanie}
\end{equation}

dla n podprzedziałów metoda prostokątów przybiera formę:

\begin{equation}
\int_a^b f(x) =  \frac{1}{2}\sum_{i=0}^n[f(x_i + f(x_{i+1}))] 
\label{Eq:rownanie}
\end{equation}

Listing 2 pokazuje przykładowy kod w języku Python implementujący metodą trapezów.

\begin{lstlisting}[caption={Kod w języku python implementujący metodę trapezów}]
import numpy as np


def f_trapI(f, a, b, n):
    h = (b - a) / n

    X = np.linspace(a, b, num=n + 1)

    Y = []
    for i in range(0, n + 1):
        Y.append(f(X[i]))

    Y = np.array(Y)

    I = []
    for i in range(0, n + 1):
        if i == 0 or i == n:
            I.append(h * Y[i] / 2)
        else:
            I.append(h * Y[i])

    I = np.sum(I)
    return I

\end{lstlisting}
\label{Listing 2}

\subsubsection{Metoda Simpsona}
Metoda Simpsona zwana też metodą parabol, to kolejny wariant metody Newtona-Cotesa. Tym razem całkę $\int_a^b f(x)$ przybliżamy przy użyciu wielomianu Lagrange'a stopnia 3, czyli paraboli.

Dla pojedyńczego podprzedziału metoda trapezów wygląda następująco:
\begin{equation}
\int_a^b f(x) =  \frac{1}{3}*h[f(a) + 4f(a+h) + f(a+2h)]
\label{Eq:rownanie}
\end{equation}

dla n podprzedziałów metoda prostokątów przybiera formę:

\begin{equation}
\int_a^b f(x) =  \frac{1}{2}h {[f(a) + f(b)] + \sum_{i=1,3,5}^{n-1}4f(x_i) + \sum_{i=2,4,6}^{n-2} f(x_i) }
\label{Eq:rownanie}
\end{equation}

Listing 3 pokazuje przykładowy kod w języku Python implementujący metodą simpsona.

\begin{lstlisting}[caption={Kod w języku python implementujący metodę simpsona}]

def f_simp2I(f,a,b,n):

    h = (b-a)/n

    I = f(a) + f(b)

    for i in range(1,n):
        if i%2==1:
            I += 4 * f(a + i*h)
        else:
            I += 2 * f(a +i*h)

    I = h/3 * I
    return I

\end{lstlisting}
\label{Listing 2}

\subsection{Kwadratury Gaussa}
Kwadratury Gaussa to metody numeryczne służące do przybliżania skończonych całek, najcześciej określane jako ważona suma wartości funkcji w określonych punktach dziedziny całkowania.
Całkowanie metodą Gauss'a opiera się na użyciu wielomianów to przybliżenia funkcji podcałkowej $f(x)$ na przedziale [-1,1], poprzez użycie odpowiednich węzłów $x_i$ oraz wag $w_i$.
	
\begin{equation}
\int_{-1}^{1} f(x) dx \approx \sum_{i=1}^{n} w_if(x_i)
\label{Eq:rownanie}
\end{equation}

Dokładność i optymalność wyniku całkowania zależy od odpowiedniego wyboru wielomianu interpolacyjnego. Użycie wielomianów Legendre'a całkowanie metodą Gaussa daje dokładny wynik dla wilomianów stopnia $2n-1$ lub niższego. 


\subsubsection{Gauss Legrande}
Kwadratura Gaussa-Legendre'a jest specjalny przypadek kwadratury Gaussa, która pozwala na efektywne przyblienie funkcji ze znanym zachowaniem asymptotycznym na brzegach przedziału całkowania. Kwadratura Gaussa jest szczególnie zalecana, jeśli całka jest holomorficzna w sąsiedztwie przediału całkowania.

Węzły $x_i$ są pierwiastkami wielomianu Legendre'a $P(x)$ stopnia n. Nie istnieje prosty sposób wyznaczenia pierwiastków $x_i$, mogę one jednak zostać aproksymowane z dużo dokładnością przy użyciu wzoru:

\begin{equation}
x_i \approx cos(\pi \frac{\frac{1}{2}+i}{N})
\label{Eq:rownanie}
\end{equation}

Wagi $w_i$ można wyrazić wzorem:

\begin{equation}
w_i = \frac{2(1-x_i^2)}{[nP_{n-1}(x_i)]^2} = \frac{2}{[P_n^1(x_i)]^2}
\label{Eq:rownanie}
\end{equation}

\cite{point}


Listing 4 pokazuje przykładowy kod w języku Python implementujący kwadrature Gauss Legendre'a.

\begin{lstlisting}[caption={Kod w języku python implementujący metodę simpsona}]

import numpy as np

def f_gauss_legrande(f,a,b,n):
    half = float(b-a)/2
    mid = (a+b)/2
    [t,w] = np.polynomial.legendre.leggauss(n)

    I = 0
    for i in range(n):
        I += w[i] * f(mid+half*t[i])

    I *= half

    return I

\end{lstlisting}
\label{Listing 4}


\subsection{Metody adaptacyjne}

Tradycyjne metody całkowania Newtona-Cotesa, ignorują fakt, że całkowana funkcja posiada regiony o dużej, jak i małej zmienności.
Metody adaptacyjne rozwiązują ten problem poprzez dostosowanie wielkości podprzedziałów, na mniejsze, w miejscach gdzie funkcja zmienia się gwałtownie i większe, w miejscach o mniejszej zmienności.\cite{adaptive}

Metody adaptacyjne polegają na wykorzystaniu tradycyjnych metod całkowania takich jak: Metoda Spimsona, trapezów do obliczenia całki na przedziale [a,b] a zadaną dokładnością $\xi$. Jeśli po pierwszej iteracji wartość całki nie jest dostatecznie dokładna, to przedział dzielimy na połowy, i ponownie całkujemy każdą z otrzymanych połówek. Proces ten powtarzamy do uzyskania zadanej dokładności.\cite{adaptive2}

Całkowita wartość całki jest obliczana jako suma przybliżeń całki na wszystkich podprzedziałach.

Na przykładzie metody trapezów adaptacyjna metoda wygląda następująco
Przedziale $[a,b]$ jest dzielona na $n$ podprzedziałów $[a_j,b_j]$, dla j = $0,1,...,n-1$, a następnie dla każdego podprzedziału obliczana jest całka według wzoru:

\begin{equation}
I_j(f) = \int_{a_j}^{b_j}f(x) dx
\label{Eq:rownanie}
\end{equation}

Powyższe podejście nie różni się niczym od klasycznej metody trapezów, jednak w metodach adaptacyjnych podprzedział $[a_j,b_j]$ jest dzielony na pół, gdy wartość $I_j(f)$ nie została obliczona z zadaną dokładnością.
Do ustalenia dokładności, używamy kwadratur na przedziale $[a_j,b_j]$, by uzyskać przybliżenie $I1j$, a następnie całkujemy funkcję dzieląc przedział $[a_j,b_j]$ na dwa podprzedziały, by obliczyć drugie przybliżenie $I_2$. Jeśli $I_1$ oraz $I_2$ są dostatecznie zbliżone, wtedy możemy stwierdzić, że przybliżenie jest wystarczające i nie ma potrzeby dalszego dzielenia $[a_j,b_j]$. W przeciwnym przypadku dzielimy $[a_j,b_j]$ na dwa podprzedziały i powtarzamy proces ponownie. Używamy tej techniki na wszystkich podprzedziałach tak długo, aż funkcja podcałkowa $f$ zostanie przybliżona z zadaną dokładnością.\cite{adaptive3}

Listing 5 pokazuje przykładowy kod w języku Python implementujący adaptacyjną metodę trapezów.

\begin{lstlisting}[caption={Kod w języku python implementujący metodę simpsona}]

def f_trapI(f,xa,xb):
    h = xb-xa
    I = h*(f(xa) + f(xb))/2
    return I

def f_adapt(f,ax,bx,tol):
    m = (ax+bx)/2.0
    P1 = f_trapI(f,ax,m)
    P2 = f_trapI(f,m,bx)

    if abs(P1 - P2 ) < 3 * tol:
        return  P2
    else:
        return f_adapt(f,ax,m,tol/2) + f_adapt(f,m,bx,tol)

\end{lstlisting}
\label{Listing 5}

\subsection{Metody Monte Carlo}

Metoda Monte Carlo to zupełnie odmienne od metod Newtona Cotesa oraz metod Gaussa podejście do obliczania wartości całki. Polega ona na obliczaniu pola powierzchni pod krzywą używając losowo rozmieszczonych punktów w obrębie granic całkowania.\\
Istnieją dwa rodzaje metod Monte Carlo.

\subsubsection{Crude Monte Carlo}
Podstawowa metoda Mone Carlo, zwana też Crude Monte Carlo polega ona na wylosowaniu $n$ punktów w obrębie przedziału całkowania i na podstawie tych danych obliczenie średniej wartości funkcji. \cite{MonteCarlo_1}

\begin{equation}
f_{sr} = \frac{f(x_1)+f(x_2) + ... + f(x_n)}{n}
\label{Eq:MonteCarlo1}
\end{equation}

Przybliżoną wartość całki otrzymujemy dzieląc uzyskaną średnią wartość funkcji przez długość przedziału całkowania.
\begin{equation}
 I = f_{sr} * |b-a| 
\label{Eq:MonteCarlo2}
\end{equation}


\subsubsection{Monte Carlo}
Bardziej dokładną wersją jest metoda Monte Carlo, która polega na wylosowaniu $n$ punktów znajdujących się w polu kwadratu, który wyznaczany jest przez przedział całkowania $<a,b>$ oraz zakres wartości funkcji w tym przedziale $<f(a),f(b)>$. Po wylosowaniu $n$ punktów wartość całki wyrażana jest jako:

\begin{equation}
I = P * \frac{c}{n}
\end{equation}

gdzie c to ilość punktów leżących się pod krzywą.\\

Wraz ze zwiększaniem ilości losowanych punktów, rozkładają się one bardziej równomiernie w obrębie wyznaczonego prostokąta, dając coraz dokładniejszy wynik.\cite{MonteCarlo_2}


\section{Błędy bezwzględne w metodach całkowania}

Błąd bezwzględny w metodzie prostokątówu wyraża się wzorem:

\begin{equation}
E_R = f'(c)\int_a^b(t-a)dt = \frac{f'(c)}{2}(b-a)^2
\label{Eq:rectError}
\end{equation}

Błąd bezwzględny w metodzie trapezów u wyraża się wzorem:

\begin{equation}
E_T = -\frac{1}{12}f''(\xi)(b-a)^3
\label{Eq:rownanie}
\end{equation}

gdzie $\xi$ leży gdzieś w przedziale [a,b]. Równanie wskazuje, że jeśli całkowana funkcja jest liniowa, metoda trapezów będzie przybliżała funkcję dokładnie.

Błąd dla wielu złożonej metody trapezów może być uzyskany przez zsumowanie pojedyńczych bęłdów w każdym segmencie
\begin{equation}
E_T = -\frac{(b-a)^3}{12n^3}\sum_{i=1}^n f''(\xi_i)
\label{Eq:rownanie}
\end{equation}

Według powyższego wzoru, jeśli ilość segmentów zostanie podwojona, błąd bezwzględny zostanie zmniejszony czterokrotnie.

Błąd bezwzględny metody Simpsona 1/3 dla pojedyńczego segmentu ma postać
\begin{equation}
E_t = -\frac{(b-a)^5}{2880}f^{4}(\xi)
\label{Eq:rownanie}
\end{equation}

Metoda simpsona daje dokładny wynik dla wielomianów stopnia 3.

Podobnie jak metoda Trapezów,  złożona metoda Simpsona, jest sumą indywidualnych błędów w poszczególnych segmentach
\begin{equation}
E_a = -\frac{(b-a)^5}{180n^4}\bar{f}^{4}(\xi)
\label{Eq:rownanie}
\end{equation}

gdzie $\bar{f}^{4}$ jest średnią czwartą pochodną przedziału

Ogólny błąd dla kwadratury Gaussa- Legendre'a wyraża się wzorem:

\begin{equation}
E_t = \frac{2^{2n+3}[(n+1)!]^4}{(2n+3)[(2n+2)!]^3}f^{2n+2}(\xi)
\label{Eq:rownanie}
\end{equation}

gdzie $n$ - liczba punktów minus jeden
$f^{2n+2}(\xi)$ - (2n+2) pochodna funkcji po zmianie zmiennej na $\xi$ ulokowanej gdzieś w przedziale [-1,1]. 


\section{Bibliotek do całkowania numerycznego}
Następne podrozdziały przedstawiają wyniki i omówienie działania zaimplementowanych przeze mnie metod całkowania dla równan \eqref{Eq:polynomial} \eqref{Eq:trygonometric} \eqref{Eq:mix}. Dla metod całkowania, których logiką działania jest liczenie całki przez podział przedziału całkowania na podprzedziały, skuteczność metody wyrażana będzie w ilości podprzedziałów, na które musiał zostać podzielony przedział całkowania, by otrzymać dokładnoć przybliżenia rzędu $0.01$ lub jeśli to możliwe, dokładną wartość całki.
Dla metod Monte Carlo skuteczność liczona będzie ilością punktów potrzebnych do uzyskania zadowalającej dokładności.
W adaptacyjnej metodzie trapezów miarą skuteczności będzie ilość wywołań funkcji, potrzebna do uzyskania zadanej dokładności przybliżenia funkcji.


Dokładność wszystkich metod całkowania zostanie zbadana na podstawie poniższych funkcji:

Funkcja wielomianoa
\begin{equation}
f(x) = 225x^5 - 300x^4 + 420x^3-185x^2+35x + 1.4
\label{Eq:polynomial}
\end{equation}

\begin{figure}
\includegraphics[scale=0.8]{C:/Users/Kamil/Desktop/Praca Dyplomowa/Praca w latex/Obrazki/Polynomial}
\caption{Wykres funkcji zdefiniowanej wzorem\eqref{Eq:polynomial}}
\end{figure}

Funkcja trygonometryczna
\begin{equation}
f(x) = sin(8x)
\label{Eq:trygonometric}
\end{equation}

\begin{figure}
\includegraphics[scale=0.8]{C:/Users/Kamil/Desktop/Praca Dyplomowa/Praca w latex/Obrazki/Trygonometric}
\caption{Wykres funkcji zdefiniowanej wzorem\eqref{Eq:trygonometric}}
\end{figure}

Funkcja mieszana
\begin{equation}
f(x) = cos(2x+2) + 13x^2
\label{Eq:mix}
\end{equation}

\begin{figure}
\includegraphics[scale=0.8]{C:/Users/Kamil/Desktop/Praca Dyplomowa/Praca w latex/Obrazki/trygonometric_polynomial}
\caption{Wykres funkcji zdefiniowanej wzorem\eqref{Eq:mix}}
\end{figure}

\subsection{Przykład użycia biblioteki}

\subsubsection{Metoda prostokątów}
	Funkcja implementująca metodę prostokątów, przyjmuje 4 parametry. Pierwszym parametrem jest badana funkcja, drugim początek dolny przedział całkowania, trzecim górny przedział całkowania, a ostatnim, ilość podprzedziałów na które dzielimy odcinek $[a,b]$. Metoda zwraca przybliżoną wartość całki.
	
	Tabela \eqref{tabela1.1} przedstawia dane otrzymane w wyniku działania implementacji metody Prostokątów dla funkcji \eqref{Eq:polynomial} na przedziale $[0,0.8]$.
	Pierwszą kolumną tabeli jest obliczona wartość całki, drugą ilość podprzedziałów dla danej iteracji, a trzecią błąd metody wyrażony jako różnica wartości całki obliczonej 			analitycznie i wartości obliczonej numerycznie.\\
	Jak widać w tabeli początkowo dla pojedyńczego podprzedziału błąd metody był bardzo duży i wynosił $-8.08110$. Wynika to z kształtu funkcji \eqref{Eq:polynomial}.\\
	Do osiągnięcia założonej dokładności metoda prostokątów potrzebowała 31 podprzedziałów.
	
\begin{lstlisting}[caption={Kod w języku python implementujący metodę prostokątów}]
def f_rectI(f,a,b,n):
    """
    """
\end{lstlisting}
\label{Listing 6}


\paragraph{Funkcja wielomianowa}\mbox{} \\

\begin{table}[H]
\centering 
\caption{Dane z iteracji w metodzie prostokątów dla funkcji wielomianowej}
\label{tabela1.1}
\begin{tabular}{lrrr}
\toprule
{} &  Wartość całki &  l.podp &      Błąd \\
\midrule
0  &       5.843200 &       1 & -8.081100 \\
1  &      11.635200 &       2 & -2.289100 \\
2  &      12.884780 &       3 & -1.039520 \\
3  &      13.335200 &       4 & -0.589100 \\
4  &      13.545974 &       5 & -0.378326 \\
5  &      13.661077 &       6 & -0.263223 \\
6  &      13.730687 &       7 & -0.193613 \\
7  &      13.775950 &       8 & -0.148350 \\
8  &      13.807020 &       9 & -0.117280 \\
9  &      13.829263 &      10 & -0.095037 \\
10 &      13.845731 &      11 & -0.078569 \\
11 &      13.858262 &      12 & -0.066038 \\
12 &      13.868017 &      13 & -0.056283 \\
13 &      13.875760 &      14 & -0.048540 \\
14 &      13.882008 &      15 & -0.042292 \\
15 &      13.887122 &      16 & -0.037178 \\
16 &      13.891361 &      17 & -0.032939 \\
17 &      13.894914 &      18 & -0.029386 \\
18 &      13.897921 &      19 & -0.026379 \\
19 &      13.900489 &      20 & -0.023811 \\
20 &      13.902699 &      21 & -0.021601 \\
21 &      13.904614 &      22 & -0.019686 \\
22 &      13.906286 &      23 & -0.018014 \\
23 &      13.907752 &      24 & -0.016548 \\
24 &      13.909047 &      25 & -0.015253 \\
25 &      13.910195 &      26 & -0.014105 \\
26 &      13.911218 &      27 & -0.013082 \\
27 &      13.912133 &      28 & -0.012167 \\
28 &      13.912955 &      29 & -0.011345 \\
29 &      13.913697 &      30 & -0.010603 \\
30 &      13.914367 &      31 & -0.009933 \\
\bottomrule
\end{tabular}
\end{table}


Tabela \eqref{tabela1.2} przedstawia dane zwrócone z działania metody prostokątów dla funkcji \eqref{Eq:trygonometric} na przedziale $[0,0.8]$.
Początkowo wartość błędu obliczonej całki jest duża, z racji przyjętego kształtu funkcji oraz przyjętego przedziału całkowania. Obie wartości funkcji na krańcach przedziałów są dodatnie oraz leżą bardzo blisko osi odciętych, przez co prostokąt przybliżający funkcje nijak ma się do rzeczywistego kształtu funkcji. Wraz ze zwiększającą się ilością podprzedziałów dokładność przybliżenia znacząco rośnie, aż dla 16 podprzedziałów przyjmuję przyjmuję zakładaną dokładność.


\paragraph{Funkcja trygonometryczna}\mbox{} \\

\begin{table}[H]
\centering 
\caption{Dane z iteracji w metodzie prostokątów dla funkcji trygonometrycznej}
\label{tabela1.2}
\begin{tabular}{lrrr}
\toprule
{} &  Wartość całki &  l.podp &      Błąd \\
\midrule
0  &       1.978716 &       1 &  1.734009 \\
1  &      -1.293375 &       2 & -1.538083 \\
2  &       1.427055 &       3 &  1.182348 \\
3  &       0.538234 &       4 &  0.293527 \\
4  &       0.391699 &       5 &  0.146991 \\
5  &       0.335697 &       6 &  0.090990 \\
6  &       0.307385 &       7 &  0.062677 \\
7  &       0.290809 &       8 &  0.046102 \\
8  &       0.280172 &       9 &  0.035465 \\
9  &       0.272899 &      10 &  0.028192 \\
10 &       0.267689 &      11 &  0.022982 \\
11 &       0.263820 &      12 &  0.019113 \\
12 &       0.260863 &      13 &  0.016156 \\
13 &       0.258550 &      14 &  0.013843 \\
14 &       0.256705 &      15 &  0.011998 \\
15 &       0.255209 &      16 &  0.010502 \\
16 &       0.253978 &      17 &  0.009271 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Metoda trapezów}

Funkcja implementująca metodę trapezów, przyjmuje dokładnie te same parametry co metoda prostokątów. Pierwszym parametrem jest funkcja podcałkowa, kolejnymi dwoma kolejno górny i dolny przedział całkowania, a ostatnim  ilość podprzedziałów, na które dzielimy przedział całkowania. Funkcja zwraca przybliżoną wartość całki.

\begin{lstlisting}[caption={Kod w języku python implementujący metodę trapezów}]
def f_trapI(f, a, b, n):
    """
    """
\end{lstlisting}
\label{Listing 7}

\paragraph{Funkcja wielomianowa}\mbox{} \\

Tabela \eqref{tabela2.1} przedstawia wyniki uzyskane z działania metody trapezów na funkcji \eqref{Eq:polynomial}.\\
Dla pojedyńczego podprzedziału błąd funkci jest bardzo duży i wynika, z tego, że wartość funkcji dla końcowych argumentów z przedziału gwałtownie rośnie, przez co prosta łącząca krańce przedziału całkowanai robi to z dużym nadmiarem. Po podzieleniu podprzedziału na 2, błąd maleje o 1 rząd wielkości, a po kolejnych 3 o kolejny rząd. Do otrzymania zadanej dokładności metoda trapezów potrzebuje 44 podprzedziałów.
\begin{table}[ht]
\centering 
\caption{Dane z iteracji w metodzie trapezów dla funkcji wielomianowej}
\label{tabela2.1}
\begin{tabular}{lrrr}
\toprule
{} &  Wartość całki &  l.podp &       Błąd \\
\midrule
0  &      31.315200 &       1 &  17.390900 \\
1  &      18.579200 &       2 &   4.654900 \\
2  &      16.018410 &       3 &   2.094110 \\
3  &      15.107200 &       4 &   1.182900 \\
4  &      14.682819 &       5 &   0.758519 \\
* &      * &      * &   * \\
39 &      13.936159 &      40 &   0.011859 \\
40 &      13.935586 &      41 &   0.011286 \\
41 &      13.935054 &      42 &   0.010754 \\
42 &      13.934558 &      43 &   0.010258 \\
43 &      13.934095 &      44 &   0.009795 \\
\bottomrule
\end{tabular}
\end{table}


\paragraph{Funkcja trygonometryczna}\mbox{} \\

Tabela \eqref{tabela2.2} przedstawia dane uzyskane z metody trapezów na funkcji podcałkowej \eqref{Eq:trygonometric}. Największy błąd dla tej funkcji pojawia się, gdy ilość podprzedziałów wynosi 3, dzieje się tak dlatego, że wartości funkcji dla granic środkowego podprzedziału przymuja bardzo niskie wartości, przez co trapez przybliżający funkcję na tym przedziale pomija całkowice całą dodatnią cześć sinusiody.\\
Metoda trapezów przyjmuję wartość z zadaną dokładnością przy ilości podprzedziałów równej 23.

że przy takim podziale każdy prawy kraniec danego podprzedziału znajduje się pod osią odciętych oraz dla każdego punku granicznego wartość funkcji przyjmują niską wartość, co skutkuje tym, że trapezy przybliżające funkcję podcałkową 

\begin{table}[H]
\centering 
\caption{Dane z iteracji w metodzie trapezów dla funkcji trygonometrycznej}
\label{tabela2.2}
\begin{tabular}{lrrr}
\toprule
{} &  Wartość całki &  l.podp &      Błąd \\
\midrule
0  &      -0.287903 &       1 & -0.532611 \\
1  &       0.845407 &       2 &  0.600699 \\
2  &      -1.269118 &       3 & -1.513825 \\
3  &      -0.223984 &       4 & -0.468692 \\
4  &      -0.011437 &       5 & -0.256145 \\
5  &       0.078969 &       6 & -0.165739 \\
6  &       0.127564 &       7 & -0.117144 \\
7  &       0.157125 &       8 & -0.087583 \\
8  &       0.176585 &       9 & -0.068122 \\
9  &       0.190131 &      10 & -0.054577 \\
10 &       0.199961 &      11 & -0.044746 \\
11 &       0.207333 &      12 & -0.037375 \\
12 &       0.213008 &      13 & -0.031699 \\
13 &       0.217474 &      14 & -0.027233 \\
14 &       0.221053 &      15 & -0.023654 \\
15 &       0.223967 &      16 & -0.020740 \\
16 &       0.226371 &      17 & -0.018336 \\
17 &       0.228379 &      18 & -0.016329 \\
18 &       0.230073 &      19 & -0.014635 \\
19 &       0.231515 &      20 & -0.013192 \\
20 &       0.232754 &      21 & -0.011954 \\
21 &       0.233825 &      22 & -0.010882 \\
22 &       0.234758 &      23 & -0.009949 \\
\bottomrule
\end{tabular}
\end{table}


\subsubsection{Metoda Simpsona}

\begin{lstlisting}[caption={Kod w języku python implementujący metodę prostokątów}]
def f_simp2I(f,a,b,n):
    """
    """
\end{lstlisting}
\label{Listing 8}

\paragraph{Funkcja wielomianowa}\mbox{} \\

Tabela \eqref{tabela3.1} przedstawia wyniki uzyskanie z działania metody Simpsona dla funkcii podcałkowej \eqref{Eq:polynomial}. Metoda Simpsona potrzebowała 6 podprzedziałów by osiągnąć zadaną dokładność.

\begin{table}[H]
\centering 
\caption{Dane z iteracji w metodzie Simpsona dla funkci wielomianowej}
\label{tabela3.1}
\begin{tabular}{lrrr}
\toprule
{} &  Wartość całki &  l.podp &      Błąd \\
\midrule
0 &      14.333867 &       2 &  0.409567 \\
1 &      13.949867 &       4 &  0.025567 \\
2 &      13.929323 &       6 &  0.005023 \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{Funkcja trygonometryczna}\mbox{} \\

Tabela \eqref{tabela3.2} przedstawia wyniki uzyskanie z działania metody Simpsona dla funkcii podcałkowej \eqref{Eq:trygonometric}. Metoda Simpsona potrzebowała 12 podprzedziałów by osiągnąć zadaną dokładność.

\begin{table}[H]
\centering
\caption{Dane z iteracji w metodzie Simpsona dla funkci trygonometrycznej}
\label{tabela3.2}
\begin{tabular}{lrrr}
\toprule
{} &  Wartość całki &  l.podp &      Błąd \\
\midrule
0 &       1.223177 &       2 &  0.978469 \\
1 &      -0.580448 &       4 & -0.825156 \\
2 &       0.528331 &       6 &  0.283623 \\
3 &       0.284161 &       8 &  0.039454 \\
4 &       0.257320 &      10 &  0.012613 \\
5 &       0.250121 &      12 &  0.005413 \\
\bottomrule
\end{tabular}
\end{table}


\subsubsection{Metoda Gaussa Legendre'a}

\begin{lstlisting}[caption={Kod w języku python implementujący metodę trapezów}]
def f_gauss_legrande(f,a,b,n):
    """
    """
\end{lstlisting}
\label{Listing 9}

\paragraph{Funkcja wielomianowa}\mbox{} \\

Tabela \eqref{tabela4.1} przedstawia wyniki uzyskanie z działania metody Gaussa Legendre'a dla funkcii podcałkowej \eqref{Eq:polynomial}. Funkcja , dla której liczona jest całka jest wielomianem stopnia 5, a metoda Gaussa Legendre'a daje wynik dokładny dla wielomianów stopnia $2n-1$, dlatego do uzyskania zadanej dokładności metoda potrzebowała 3 węzłów interpolacyjnych. Uzyskany błąd wynika z zaokrągleń.

\begin{table}[H]
\centering 
\caption{Dane z iteracji w metodzie Gauss'a Legendre'a dla funkcji wielomianowej}
\label{tabela4.1}
\begin{tabular}{lrrr}
\toprule
{} &  Wartość całki &  l.podp &      Błąd \\
\midrule
0 &       5.843200 &       1 & -8.081100 \\
1 &      13.651200 &       2 & -0.273100 \\
2 &      13.924267 &       3 & -0.000033 \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{funkcja trygonometryczna}\mbox{} \\

Tabela \eqref{tabela4.2} przedstawia wyniki uzyskanie z działania metody Gaussa Legendre'a dla funkcii podcałkowej \eqref{Eq:trygonometric}. Całkowana funkcja nie jest wielomianem, więc uzyskanie dokładnej wartości przy użyciu metody Gaussa jest niemożliwe, lecz jej kształ sprawia, że daje się ona łatwo przybliżyć, przy użyciu wielomianów, co skutkuje, że do uzyskania zakładanej dokładności kwadratura Gaussa potrzebowałą 7 węzłów interpolacyjnych.

\begin{table}[H]
\centering
\caption{Dane z iteracji w metodzie Gauss'a Legendre'a dla funkcji trygonometrycznej}
\label{tabela4.2}
\begin{tabular}{lrrr}
\toprule
{} &  Wartość całki &  l.podp &      Błąd \\
\midrule
0 &       1.978716 &       1 &  1.734009 \\
1 &      -0.184912 &       2 & -0.429619 \\
2 &       1.974615 &       3 &  1.729907 \\
3 &      -0.611561 &       4 & -0.856269 \\
4 &       0.456455 &       5 &  0.211748 \\
5 &       0.212634 &       6 & -0.032073 \\
6 &       0.248022 &       7 &  0.003315 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Metoda adaptacyjna trapezów}

\begin{lstlisting}[caption={Kod w języku python implementujący metodę trapezów}]
def f_adapt(f,ax,bx,tol):
    """
    """
\end{lstlisting}
\label{Listing 10}

\paragraph{Funkcja wielomianowa}\mbox{} \\

Tabela \eqref{tabela5.1} przedstawia wyniki uzyskanie z działania metody Adaptacyjnej Trapezów dla funkcii podcałkowej \eqref{Eq:polynomial}. Pomimo tego, że bład nie jest mniejszy niż zakładana tolerancja, to obie te wartości zmniejszają się razem, oraz mają taki sam rząd wielkości.

\begin{table}[H]
\centering 
\caption{Dane z iteracji w metodzie Adaptacyjnej Trapezów dla funkcji wielomianowej}
\label{tabela5.1}
\begin{tabular}{lrrrr}
\toprule
{} &  Wartość całki &  l.wywołań funkcji &  Tol &      Błąd \\
\midrule
0 &       14.087879687500003 &  7  &   0.1 & -0.16357968750000218\\
1 &       13.95071159667969 &  21 &   0.01 & -0.026411596679690064\\
2 &       13.92913151855469 &  47  &  0.001 & -0.004831518554690106 \\
3 &       13.925455606651312 &  97  &  0.0001  & -0.0011556066513112029 \\
4 &       13.925455606651312 &  207  &  0.00001  & -0.00026474552704236487 \\
5 &       13.924337389287741 &  441  &  0.000001  & -0,0000373892877405523 \\
6 &       13.924280646049143 &  999  &  0.0000001  & 0,0000193539508579476 \\
7 &       13.92426944676001 &  2207  &  0.00000001  & 0,000030553239991348846 \\
8 &       13.924267226688606 &  4811  &  0.000000001  & 0,0000327733113945072 \\
9 &       13.92426678139501 &  10345  &  0.0000000001  & 0,00003321860499028162 \\
10 &      13.924266690629675 &  22017  &  0.00000000001  & 0,0000333093703250853 \\
11 &      13.924266671787425 &  46421  &  0.000000000001 & 0,000033328212575511884 \\
12 &      13.924266667844629 &  98387  &  0.0000000000001  & 0,000033332155371823546e \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{Funkcja trygonometryczna}\mbox{} \\


Tabela \eqref{tabela5.2} przedstawia wyniki uzyskanie z działania metody Adaptacyjnej Trapezów dla funkcii podcałkowej \eqref{Eq:trygonometric}.


\begin{table}[H]
\centering 
\caption{Dane z iteracji w metodzie Adaptacyjnej Trapezów dla funkcji trygonometrycznej}
\label{tabela5.2}
\begin{tabular}{lrrrr}
\toprule
{} &  Wartość całki &  l.podprzedziałów &  Tol &      Błąd \\
\midrule
0 &       0.275097393643396 &  12  &   0.1 & -0.030389958602972944 \\
1 &       0.22651620332825226 &  26 &   0.01 & 0.018191231712170824 \\
2 &       0.24356462655643027 &  54  &  0.001 & 0.0011428084839928132 \\
3 &       0.24428699646689261 &  116  &  0.0001  & 0.0004204385735304683 \\
4 &       0.24464360546255373 &  234  &  0.00001  & 0.00006382957786935095 \\
5 &       0.24468621101711638 &  476  &  0.000001  & 0,000021224023306704 \\
6 &       0.24470234198590066 &  964  &  0.0000001  & 0,00000509305452242592 \\
7 &       0.2447062019886146 &  1952  &  0.00000001  & 0,000000233051808491314 \\
8 &       0.24470726279412686 & 5571  &  0.000000001  & 0,000000172246296226141 \\
9 &       0.24468621101711638 & 12406  & 0.0000000001  & 0,0000000326823607066373 \\
10 &      0.24470742830603642 & 26536  & 0.00000000001  & 0,00000000673438665943493 \\
11 &      0.24470743356253416 & 55622  &0.000000000001  & 0,00000000147788892235212 \\
12 &      0.24470743470247994 & 115119  & 0.0000000000001  & 0,000000000337943145689578 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Metoda Crude Monte Carlo}

\begin{lstlisting}[caption={Kod w języku python implementujący metodę Crude Monte Carlo}]
def f_crudeMonteC(f,a,b,n):
    """
    """
\end{lstlisting}
\label{Listing 11}

\paragraph{Funkcja wielomianowa}\mbox{} \\

W tabeli \eqref{tabela6.1} przedstawiono wyniki uzyskanie z działania metody Crude Monte Carlo dla funkcii podcałkowej \eqref{Eq:polynomial}.
Otrzymany błąd dla jednego podprzedziału może wydawać, się zaskakująco mały, lecz trzeba wziąć pod uwagę, że jest on średnim błędem dla 100 iteracji. Dla jednego podprzedziału wartości całki może się wahać od 1.2 do 61.5103. Wraz ze zwiększaniem ilości punktów, zakres otrzymywanych wyników ulega zmniejszeniu. w tabeli można również zauważyć, że wartości otrzymane dla 100 jak i 1000 punktów, są bardzo podobne i wynika to ze "szczęścia" z jakim punkty zostaną wylosowane.
Przy 1000 losowych punktów średni otrzymany błąd przybliżenia wynosi 0.01%.


\begin{table}[H]
\centering 
\caption{Dane z iteracji w metodzie Crude Monte Carlo dla funkcji wielomianowej}
\label{tabela6.1}
\begin{tabular}{lrrrrr}
\toprule
{Row} &  Points &  minValue &  maxValue &       AVG &      Błąd \\
\midrule
1  &     1 & 1.416807038 &   60.99560428 & 11.987235 & 13.91\% \\
1  &     10 & 2.70581996 &   26.80458791 & 13.662372 & 1.88\% \\
2  &     100 & 10.89037611 &  19.49690441 & 13.98955& 0.47\% \\
3  &     1000 & 12.37476196 &   14.94271099 & 13.941598 & 0.12\% \\
4  &     10000 & 13.61746918 &  14.30824118 & 13.906282 & 0.13\% \\
5  &     100000 & 13.76707602 &  14.03293431 & 13.922587 & 0.01\% \\
\bottomrule
\end{tabular}
\end{table}


\paragraph{Funkcja trygonometryczna}\mbox{} \\

Tabela \eqref{tabela6.2} przedstawia wyniki uzyskanie z działania metody Crude Monte Carlo dla funkcii podcałkowej \eqref{Eq:trygonometric}.
Na podstawie pierwszych 3 wierszy tabeli widać, że otrzymywany błąd wraz z dziecięsiokrotnym wzrostem ilości punktów maleje około 4-krotnie.
Dalsze 1-krotne zwiększanie ilości użytych punktów  daje około 7-krotne zmniejszenie błędu. Przy 10000 punktów błąd maleje o połowę, a użycie 100000 daje błąd przybliżenia całki na poziomie 0.12%.


\begin{table}[H]
\centering 
\caption{Dane z iteracji w metodzie Crude Monte Carlo dla funkcji trygonometrycznej}
\label{tabela6.2}
\begin{tabular}{lrrrrr}
\toprule
{Row} &  Points &  minValue &  maxValue &       AVG &      Błąd \\
\midrule
1  &     1 & -1.999712843 &   1.999075162 & 0.438109 & 79.03\% \\
1  &     10 & -0.6383128719 &  1.133784472 & 0.190505 & 22.15\% \\
2  &     100 & -0.1079735697 &  0.5645576157 & 0.261066 & 6.68\% \\
3  &     1000 & 0.1529912591 &   0.3583314798 & 0.246922 & 0.9\% \\
4  &     10000 & 0.2148820935 &  0.2831131619 & 0.243623 & 0.44\% \\
5  &     100000 & 0.2349722501 &  0.2594303218 & 0.244408 & 0.12\% \\
\bottomrule
\end{tabular}
\end{table}


\subsubsection{Metoda Monte Carlo}

\begin{lstlisting}[caption={Kod w języku python implementujący metodę Monte Carlo}]
def f_MonteC(f,a,b,n):
    """
    """
\end{lstlisting}
\label{Listing 11}

\paragraph{Funkcja wielomianowa}\mbox{} \\

Tabela \eqref{tabela7.1} przedstawia wyniki uzyskanie z działania metody Monte Carlo dla funkcii podcałkowej \eqref{Eq:polynomial}.

\begin{table}[H]
\centering 
\caption{Dane z iteracji w metodzie Monte Carlo dla funkcji wielomianowej}
\label{tabela7.1}
\begin{tabular}{lrrrrr}
\toprule
{Row} &  Points &  minValue &  maxValue &       AVG &      Błąd \\
\midrule
1  &     10 & 1,853055156 &   26,60291651 & 11,033428 & 20,76\% \\
2  &     100 & 6,629125753 &  18,74562867 & 12,657178 & 9,1\% \\
3  &     1000 & 10,92932294 &   14,48626121 & 12,808812 & 8,01\% \\
4  &     10000 & 12,17390193 &  13,47542511 & 12,777447 & 8,24\% \\
5  &     100000 & 12,649035 &  12,98188584 & 12,806892& 8,02\% \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{Funkcja trygonometryczna}\mbox{} \\

Tabela \eqref{tabela7.2} przedstawia wyniki uzyskanie z działania metody Monte Carlo dla funkcii podcałkowej \eqref{Eq:trygonometric}.

\begin{table}[H]
\centering 
\caption{Dane z iteracji w metodzie Monte Carlo dla funkcji trygonometrycznej}
\label{tabela7.2}
\begin{tabular}{lrrrrr}
\toprule
{Row} &  Points &  minValue &  maxValue &       AVG &      Błąd \\
\midrule
1  &     10 & -1,928549934 &   1,816778457 & 0,211325 & 13,64\% \\
2  &     100 & -2,098836469 &  2,203746727 & 0,215333 & 12\% \\
3  &     1000 & -2,393655983 &   2,760053799 & 0,243658 & 0,43\% \\
4  &     10000 & -3,115304313 &  3,196864709 & 0,243453 & 0,51\% \\
5  &     100000 & -2,799281898 &  3,260480744 & 0,243275 & 0,59\% \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Porównanie zbieżności}

Tabela \eqref{tabela9.1} przedstawia porównanie metod całkowania opartych o interpolację wielomianową dla 2 podprzedziałów.
Jak widzimy metodą dającą najgorszy wynik jest Metoda Trapezów, zwraca ona wynik 2-krotnie gorszy niż Metoda Prostokątów. 
Metoda Simpsona daje o 1 rząd wielkości błąd mniejszy niż metody trapezów i prostokątów. 
Metoda Gaussa Legendrea uzyskała błąd prawie o połowę niższy niż metoda Simpsona.

\begin{table}
\centering 
\caption{Tabela porównująca metody całkowania oparte na interpolacji wielomianem dla 2 podprzedziałów }
\label{tabela9.1}
\begin{tabular}{lrrr}
\toprule
{l.podp} & Metoda &  l.podp &  Błąd \\
\midrule
2  &     Prostokątów & 11.6352 &   2.2891  \\
2  &     Trapezów & 18.579200 &  4.654900  \\
2  &     Simpsona & 14.333867 &   0.409567  \\
2  &     Gaussa Legendre & 13.651200 &  0.273100  \\
\bottomrule
\end{tabular}
\end{table}


W tabeli \eqref{tabela9.2} umieszczone zostały wyniki z działania metod dla 4 podprzedziałów.
Jak widać w tabeli stosunek różnicy pomiędzy metodą Prostokątów i Trapezów pozostał podobny.
Błąd w metodzie Prostokątów i Trapezów wynosi $\frac{1}{2^2}$ w stosunku do błędu dla 2 podprzedziałów.
W metodzie Simpsona wraz z podwojeniem podprzedziałów błąd zmniejsza się o $\frac{1}{2^4}$.
Metoda Gaussa Legendrea daje wynik dokładny dla wielomianów stopnia $2n-1$, w związku z czym już dla 3 węzłów zwróciła ona wynik dokładny.


\begin{table}
\centering 
\caption{Tabela porównująca metody całkowania oparte na interpolacji wielomianem dla 4 podprzedziałów }
\label{tabela9.2}
\begin{tabular}{lrrr}
\toprule
{l.podp} & Metoda &  l.podp &  Błąd \\
\midrule
4  &     Prostokątów & 13.33520 &   0.58910  \\
4  &     Trapezów & 15.107200 &  1.182900  \\
4  &     Simpsona & 13.949867 &   0.025567  \\
4  &     Gaussa Legendre & 13.924267 &  0.000033  \\
\bottomrule
\end{tabular}
\end{table}



Porównanie metody Simpsona oraz Gaussa Legendra dla funkcji trygonometrycznej.

Jak widać w tabeli \eqref{tabela9.3} początkowoa metoda Simpsona wykazuje dokładniejsze przybliżenie całki niż metoda Gaussa Legendre'a, przy 6 podprzedziałach zwraza błąd 10-krotnie mniejszy. Dopiero gdy liczba podprzedziałów wynosi 8 metoda Gaussa okazuje się być lepsza i zwracać błąd mniejszy o 2 rzędy wielkości. 
Przy 10 podprzedziałach kwadratura Gaussa zwraca wynik dokładny jeśli zaokrąglimy analitycznie obliczoną całkę do 6 miejsca po przecinkuo.

\begin{table}
\centering 
\caption{Tabela porównująca Gaussa i Simpsona }
\label{tabela9.3}
\begin{tabular}{lrrr}
\toprule
{l.podp} & Metoda &  I &  Błąd \\
\midrule
2  &     Simpsona & 1.223177 &   9.784691e-01 \\
4  &     Simpsona & -0.580448  &   8.251555e-01  \\
6  &     Simpsona &  0.528331  &   2.836232e-01  \\
8  &     Simpsona & 0.284161 &   3.945382e-02  \\
10 &     Simpsona & 0.257320 &   1.261270e-02  \\
2  &     Gaussa Legendre & -0.184912 &  4.296190e-01   \\
4  &     Gaussa Legendre & -0.611561 &  8.562686e-01   \\
6  &     Gaussa Legendre & 0.212634 &  3.207296e-02   \\
8  &     Gaussa Legendre & 0.244457 &  2.499462e-04  \\
10 &     Gaussa Legendre & 0.244707 &  6.560406e-07  \\

\bottomrule
\end{tabular}
\end{table}




Porównanie metody Trapezów i Adaptacyjnej metody trapezów dla funkcji 

Tabela \eqref{tabela9.4} przedstawia porównanie Metody Trapezów i Adaptacyjnej Metody Trapezów. Porównanie zostało przeprowadzone na funkcji \eqref{Eq:polynomial}. Funkcja ta wraz ze wzrostem wartości argumentów przyjmuje coraz większą wartość, przez co żeby metoda mogła osiągnąć zadeklarowaną dokładność, dzieli prawą stronę równania na mniejsze podprzedziały, gdzie zwykła metoda trapezów dzieli funkcję na podprzedziały równo rozmieszczone wzdłuż całego przedziału całkowania. Stąd wynik uzyskany przez metodę trapezów jest 2-krotnie dokładniejszy dla ostatnich dwóch iteracji pokazanych w tabeli.

\begin{table}
\centering 
\caption{Tabela porównująca metodę trapezów i adaptacyjną metodę Trapezów}
\label{tabela9.4}
\begin{tabular}{lrrr}
\toprule
{l.podp} & Metoda &  I &  Błąd \\
\midrule
4  &     Trapezów & 15.1072  &   1.1829 \\
6  &     Trapezów & 14.451595 &   0.527295 \\
8  &     Trapezów & 14.2212   &   0.2969  \\
10  &    Trapezów & 14.158947  &   0.234647  \\
12  &    Trapezów & 14.056336 &    0.132036  \\
16 &     Trapezów & 13.998575  &   0.074275  \\

4  &     Adaptacyjna & 15.1072 &   1.1829 \\
6  &     Adaptacyjna & 14.236700 &   0,3124 \\
8  &     Adaptacyjna & 14,08788  &   0,16358  \\
10  &     Adaptacyjna & 14.017669 &  0,093369  \\
12  &    Adaptacyjna & 13.995822 &   0,071522  \\
16 &     Adaptacyjna & 13.95722 &    0,03292  \\

\bottomrule
\end{tabular}
\end{table}

Metoda adaptacyjna radzi sobię lepiej od metody trapezów gdy całkowana funkcja przyjmuje różne tempo zmian wartości na zadanym przedziale. Przykładem takiej funkcji jest \eqref{Eq:oscillatory}. Funkcja ta coraz bardziej oscyluje w pobliżu prawego punktu końcowego.\\
Wyniki działania obu metod całkowania tej funkcji prezentuje tebela \eqref{tabela9.5}.\\
Liczba podprzedziałów nie jest parametrem metody adaptacyjnej dlatego została dobrana na podstawie tego na jaką ilość podprzedziałów została podzielona funkcja przy zadanej tolerancji.\\
Dla 4 podprzedziałów widzimy, że zadana tolerancja była na tyle duża, że metoda adaptacyjna podzieliła przedział całkowania w ten sam sposób co metoda trapezów.
Wraz ze wzrostem ilości podprzedziałów adaptacyjna metoda wykazuje znacznie lepszą dokładność w przybliżaniu całki. Dla 98 podprzedziałów błąd metody adaptacyjnej jest o 2 rzędy wielkości mniejszy niż przy zwykłej metodzie trapezów.

\begin{table}
\centering 
\caption{Tabela porównująca metodę trapezów i adaptacyjną metodę Trapezów}
\label{tabela9.5}
\begin{tabular}{lrrr}
\toprule
{l.podp} & Metoda &  I &  Błąd \\
\midrule
4  &     Trapezów & 9.731300  &   12.556630 \\
8  &     Trapezów & -8.227000 &   -5.401670 \\
10  &     Trapezów & 7.068914   &   9.894244  \\
18  &    Trapezów & 5.822512  &   -2.997182  \\
46  &    Trapezów & -2.827854 &    -0.002524   \\
56 &     Trapezów & -1.467744  &   1.357586  \\
98 &     Trapezów & 2.295961 &   0.529369  \\

4  &     Adaptacyjna & 9.731300 &   -12.556630 \\
8  &     Adaptacyjna & -9.439613 &   6.614283 \\
10  &     Adaptacyjna & -11.1515886  &   8.326258  \\
18  &     Adaptacyjna & -3.881971 &  1.056641  \\
46  &    Adaptacyjna & -2.868944 &   0.043614  \\
56 &     Adaptacyjna & -2.846306 &    0.020976  \\
98 &     Adaptacyjna & -2.825574 &    0.000244  \\

\bottomrule
\end{tabular}
\end{table}


Porównanie metod Monte Carlo

Tabela \eqref{tabela9.6} przedstawia wyniki z całkowania funkcji \eqref{Eq:trygonometric} metodami Crude Monte Carlo oraz Monte Carlo.

\begin{table}
\centering 
\caption{Tabela porównująca metodę Crude Monte Carlo oraz Monte Carlo dla funkcji trgonometrycznej}
\label{tabela9.6}
\begin{tabular}{lrrr}
\toprule
{l.podp} & Metoda &  I &  Błąd \\
\midrule
10  &     Crude & 0.217109  &   0.027599 \\
100  &     Crude & 0.284756 &   0.040048 \\
1000  &    Crude & 0.25273   &   0.008022  \\
10000  &    Crude & 0.245071  &   0.000364  \\
100000  &    Crude & 0.244593 &    0.000115   \\
1000000  &    Crude & 0.244602 &    0.000106   \\

10  &     Monte Carlo & 0.144  &   0.100707 \\
100  &     Monte Carlo & 0.2384  &   0.006307 \\
1000  &    Monte Carlo & 0.24528   &   0.000573  \\
10000  &    Monte Carlo & 0.247472  &   0.002765  \\
100000  &    Monte Carlo & 0.245164 &    0.000457   \\
1000000  &    Monte Carlo & 0.245026 &    0.000318   \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}
\includegraphics[scale=0.8]{C:/Users/Kamil/Desktop/Praca Dyplomowa/Praca w latex/Obrazki/Błąd metod Monte Carlo dla funkcji sin(8x)}
\caption{Wykres funkcji zdefiniowanej wzorem\eqref{Eq:polynomial}}
\end{figure}


Tabela \eqref{tabela9.6} przedstawia wyniki uzyskane z całkowania funkcji \eqref{Eq:polynomial} metodami Crude Monte Carlo oraz Monte Carlo.


\begin{table}
\centering 
\caption{Tabela porównująca metodę Crude Monte Carlo oraz Monte Carlo dla funkcji wielomianowej}
\label{tabela9.7}
\begin{tabular}{lrrr}
\toprule
{l.podp} & Metoda &  I &  Błąd \\
\midrule
10  &     Crude & 13,43583  &   0,48847 \\
100  &     Crude & 14,133026 &   0,208726 \\
1000  &    Crude & 13,825492  &   0,098808  \\
10000  &    Crude & 13,945694  &   0,021394  \\
100000  &    Crude & 13,925673 &    0,001373   \\
1000000  &    Crude & 13,92384 &    0,00046   \\

10  &     Monte Carlo & 14,331923  &   0,407623 \\
100  &     Monte Carlo & 13,895199 &   0,029101\\
1000  &    Monte Carlo & 13,878592   &   0,045708  \\
10000  &    Monte Carlo & 13,910085  &   0,014215  \\
100000  &    Monte Carlo & 13,93213 &    0,00783   \\
1000000  &    Monte Carlo & 13,92549 &    0,00119   \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}
\includegraphics[scale=0.8]{C:/Users/Kamil/Desktop/Praca Dyplomowa/Praca w latex/Obrazki/Błąd metod Monte Carlo dla funkcji wielomianowej}
\caption{Wykres funkcji zdefiniowanej wzorem\eqref{Eq:polynomial}}
\end{figure}

\section{Podsumowanie i wnioski końcowe}

1 $\div$ 3 stron merytorycznie podsumowanie najważniejszych elementów pracy oraz wnioski wynikające z osiągniętego celu pracy. Proponowane zalecenia i modyfikacje oraz rozwiązania będące wynikiem realizowanej pracy.

Ostatni akapit podsumowania musi zawierać wykaz własnej pracy dyplomanta i zaczynać się od sformułowania: „Autor za własny wkład pracy uważa: \ldots”.

\clearpage

\section*{Załączniki}
\addcontentsline{toc}{section}{Załączniki}

Według potrzeb zawarte i uporządkowane uzupełnienie pracy o dowolny materiał źródłowy (wydruk programu komputerowego, dokumentacja kons\-truk\-cyj\-no-\-tech\-no\-lo\-gicz\-na, konstrukcja modelu -- makiety -- urządzenia, instrukcja obsługi urządzenia lub stanowiska laboratoryjnego, zestawienie wyników pomiarów i obliczeń, informacyjne materiały katalogowe itp.).


\clearpage

\addcontentsline{toc}{section}{Literatura}

\begin{thebibliography}{4}
\bibitem{Intro1} https://en.wikipedia.org/wiki/Numerical\_integration
\bibitem{wikipedia} https://en.wikipedia.org/wiki/Newton%E2%80%93Cotes_formulas
\bibitem{web} Willie Aboumrad, CME 108/MATH 114 Introduction to Scientific Computing
\bibitem{rect} https://www.cs.mcgill.ca/
\bibitem{point} Abramovitz, Milton; I. Stegun (1964). Handbook of mathematical functions. National Bureau of Standards. ISBN 0-486-61272-4.
\bibitem{adaptive} Numerical Methods for Engineers, 6th Ed
\bibitem{adaptive2} https://www.mimuw.edu.pl/~leszekp/dydaktyka/MO19L-g/adaptn.pdf
\bibitem{adaptive3} https://www.math.usm.edu/lambers/mat460/fall09/lecture30.pdf
\bibitem{trapError} https://home.agh.edu.pl/~zak/downloads/wyk5.pdf
\bibitem{MonteCarlo_1} http://www.algorytm.org/procedury-numeryczne/calkowanie-numeryczne-metoda-monte-carlo-ii.html
\bibitem{MonteCarlo_2} http://www.algorytm.org/procedury-numeryczne/calkowanie-numeryczne-metoda-monte-carlo-i.html
\bibitem{str} http://weii.portal.prz.edu.pl/pl/materialy-do-pobrania. Dostęp 5.01.2015.
\bibitem{Jakubczyk1997} Jakubczyk T., Klette A.: Pomiary w akustyce. WNT, Warszawa 1997.
\bibitem{Barski2011} Barski S.: Modele transmitancji. Elektronika praktyczna, nr 7/2011, str. 15-18.
\bibitem{dokum} Czujnik S200. Dokumentacja techniczno-ruchowa. Lumel, Zielona Góra, 2001.
\bibitem{Pawluk2001} Pawluk K.: Jak pisać teksty techniczne poprawnie, Wiadomości Elektrotechniczne, Nr 12, 2001, str. 513-515.
\end{thebibliography}

\clearpage

\makesummary

\end{document} 
